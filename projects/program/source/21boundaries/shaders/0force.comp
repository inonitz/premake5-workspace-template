#version 450 core
layout(local_size_x =   5, local_size_y =   5, local_size_z =   5) in;
layout(binding = 0)                    uniform sampler2D previousFrame;
layout(binding = 1, rgba32f) writeonly uniform image2D   nextFrame;


vec4 drawPointAt(
    in vec2  currPoint, 
    in vec2  desiredPoint, 
    in float radius,
    in vec4  initialColor,
    in bool  clampAtEdges
);


uniform ivec2 ku_simdims;
uniform ivec2 ku_windims;
uniform float ku_dt;
uniform float ku_splatterRadius; /* in pixels */
uniform vec2  ku_mouseDragForce;
uniform vec2  ku_mouseDragPos;   /* in pixels (screen space) */
uniform vec4  ku_splatterValue;
uniform uint  ku_mousePressed;
uniform uint  ku_chooseInteractionType;


vec2 k_winUnitCoord = vec2(1) / vec2(ku_windims);
vec2 k_unitCoord = vec2(1) / vec2(ku_simdims);


void main()
{
    ivec2 texelCoord;
    vec2 norm_texcoord, norm_mousepos;
    vec4 userInteractionValue = vec4(0);


    texelCoord = ivec2(gl_GlobalInvocationID.xy);
    norm_texcoord = vec2(texelCoord) * k_unitCoord;

    norm_mousepos = ku_mouseDragPos * k_winUnitCoord;
    norm_mousepos.y = 1.0f - norm_mousepos.y;


    if(bool(ku_mousePressed)) {
        switch(ku_chooseInteractionType) {
            case 0: /* Dye */
            userInteractionValue = drawPointAt(
                norm_texcoord,
                norm_mousepos,
                ku_splatterRadius,
                ku_splatterValue,
                true
            );
            break;
            case 1: /* Force */
            userInteractionValue = ku_dt * drawPointAt(
                norm_texcoord,
                norm_mousepos,
                ku_splatterRadius,
                vec4(normalize(ku_mouseDragForce), 0, 0),
                false
            );
            break;
            case 2: /* Boundary */
            userInteractionValue = drawPointAt(
                norm_texcoord,
                norm_mousepos,
                ku_splatterRadius,
                vec4(1),
                true
            );
            userInteractionValue = vec4(float( 
                any(
                    greaterThan(userInteractionValue, vec4(0.0f))
                ) 
            ));
            break;
            default:
            break;
        }
    }


    imageStore(nextFrame, texelCoord,
        + texelFetch(previousFrame, texelCoord, 0) 
        + userInteractionValue
    );
    return;
}


vec4 drawPointAt(
    in vec2  currPoint, 
    in vec2  desiredPoint, 
    in float radius,
    in vec4  value,
    in bool  clampAtEdges
) {
    float dist = length(currPoint - desiredPoint) / radius;
    vec4  result = exp(-dist*dist) * value;

    /* if we're clamping, outside the radius should be 0 color. */
    float toclamp = float(clampAtEdges) * float(dist < 1) + float(!clampAtEdges); 
    result *= toclamp;
    return result;
}
