#version 450 core
layout(local_size_x =   5, local_size_y =   5, local_size_z =   5) in;
layout(binding = 0)                    uniform sampler2D previousFrame;
layout(binding = 2)                    uniform sampler2D optionalBuoyancy;
layout(binding = 1, rgba32f) writeonly uniform image2D   nextFrame;


vec4 drawPointAt(
    in vec2  currPoint, 
    in vec2  desiredPoint, 
    in float radius,
    in vec4  initialColor
);
vec2 addForceAt(
    in vec2  currPoint, 
    in vec2  desiredPoint, 
    in float radius,
    in vec2  force
);
vec2 vorticityForce(
    in sampler2D tex,
    in ivec2     texel,
    in float     scale
);


uniform ivec2 ku_simdims;
uniform ivec2 ku_windims;
uniform float ku_dt;
uniform float ku_vorticityFactor;
uniform float ku_densityFactor;
uniform float ku_temperatureFactor;
uniform float ku_ambientTemperature;
uniform float ku_splatterRadius; /* in pixels */
uniform vec2  ku_simUnitCoord;
uniform vec2  ku_mouseDragForce;
uniform vec2  ku_mouseDragPos;   /* in pixels (screen space) */
uniform vec4  ku_splatterColor;
uniform uint  ku_mousePressed;
uniform uint  ku_addForce;
uniform uint  ku_useVorticity;
uniform uint  ku_useBuoyancy;


vec2 k_winUnitCoord = vec2(1) / vec2(ku_windims);
vec2 k_unitCoord = vec2(1) / vec2(ku_simdims);
vec2 k_rdxdy = 1.0f / ku_simUnitCoord;
vec3 k_rdxdydz = vec3(k_rdxdy, 0);


void main()
{
    ivec2 texelCoord;
    vec2 norm_texcoord, norm_mousepos;
    vec4 dyeSource, forceSource;

    texelCoord = ivec2(gl_GlobalInvocationID.xy);
    norm_texcoord = vec2(texelCoord) * k_unitCoord;

    norm_mousepos = ku_mouseDragPos * k_winUnitCoord;
    norm_mousepos.y = 1.0f - norm_mousepos.y;

    dyeSource = drawPointAt(
        norm_texcoord,
        norm_mousepos,
        ku_splatterRadius,
        ku_splatterColor
    );
    forceSource = vec4(
        addForceAt(
            norm_texcoord,
            norm_mousepos,
            ku_splatterRadius,
            normalize(ku_mouseDragForce)
        ), 0, 0
    );

    vec4 vorticity = vec4(0);
    if(bool(ku_useVorticity)) {
        vorticity = vec4(
            vorticityForce(
                previousFrame, 
                texelCoord, 
                ku_vorticityFactor
            ),
            0, 0
        );
    }

    vec4 buoyancy = vec4(0);
    if(bool(ku_useBuoyancy))
    {
        vec2 smokeqtty = texelFetch(optionalBuoyancy, texelCoord, 0).xy;
        buoyancy.y = 
            - ku_densityFactor * smokeqtty.x 
            + ku_temperatureFactor * (smokeqtty.y - ku_ambientTemperature);
        buoyancy.y *= ku_dt;
    }


    imageStore(nextFrame, texelCoord,
        + texelFetch(previousFrame, texelCoord, 0) 
        + float(ku_mousePressed) * mix(dyeSource, forceSource, float(ku_addForce))
        + vorticity
        + buoyancy
    );
    return;
}


vec4 drawPointAt(
    in vec2  currPoint, 
    in vec2  desiredPoint, 
    in float radius,
    in vec4  initialColor
) {
    float dist = length(currPoint - desiredPoint) / radius;
    vec4  result = exp(-dist*dist) * initialColor;
    result *= float(dist < 1); /* don't return any color if false */
    return result;
}


vec2 addForceAt(
    in vec2  currPoint, 
    in vec2  desiredPoint, 
    in float radius,
    in vec2  force
) {
    float dist = length(currPoint - desiredPoint) / radius;
    vec2  result = force * ku_dt * exp(-dist*dist);
    // result *= float(dist < 1); /* don't return any color if false */
    return result;
}


/* 
    Thanks to:
    https://scicomp.stackexchange.com/questions/21915/discrete-definitions-of-curl-nabla-times-f
*/
float curl2D(
    in sampler2D tex,
    in ivec2     texel
) {
    float samples[4] = float[4](
        texelFetch(tex, texel + ivec2(1, 0), 0).x,
        texelFetch(tex, texel - ivec2(1, 0), 0).x,
        texelFetch(tex, texel + ivec2(0, 1), 0).y,
        texelFetch(tex, texel - ivec2(0, 1), 0).y
    );
    
    vec2 temp = vec2(samples[2] - samples[3], samples[0] - samples[1]);
    temp *= k_rdxdy * 0.5f;
    
    return temp.x - temp.y;
}


float cross2D(
    in vec2 A,
    in vec2 B
) {
    /* result in 3d = (0, 0, return_value) */
    return A.x * B.y - A.y * B.x;
}


vec2 vorticityForce(
    in sampler2D tex,
    in ivec2     texel,
    in float     scale
)  {
    float samples[4] = float[4](
        abs( curl2D(tex, texel + ivec2(1, 0)) ),
        abs( curl2D(tex, texel - ivec2(1, 0)) ),
        abs( curl2D(tex, texel + ivec2(0, 1)) ),
        abs( curl2D(tex, texel - ivec2(0, 1)) )
    );
    float curlij = curl2D(tex, texel);

    vec2 grad = 0.5f * k_rdxdy * vec2(
        samples[0] - samples[1], 
        samples[2] - samples[3]
    );
    vec2 psi = normalize(grad);

    // vec3 result = scale * vec3(ku_simUnitCoord, 0) * cross(
    //     vec3(psi,       0),
    //     vec3(0, 0, curlij)
    // );
    vec2 result = scale * ku_dt * ku_simUnitCoord * vec2(psi.y, psi.x) * curlij;
    return result;
}